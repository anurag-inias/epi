# Computing the parity of a word

## Description

Find parity of a given binary sequence.

## Example

```
 input = 0b1011
parity = 1

 input = 0b10001000
parity = 0
```

## Stub

```java
public static short parity(long x) {
  // return here
}
```

## Solution

??? "First approach"

    From [bit tricks section](https://listless.dev/data-structures/numbers/bit-tricks/) we know that $x \ \& \ (x-1)$ will unset the rightmost $1$.

    ```java
    public static short parity(long x) {
      int parity = 0;
      while (x != 0) {
        parity = 1 - parity;
        x = x & (x - 1);
      }
      return (short) parity;
    }
    ```

    $O(k)$ where $k$ is number of set bits.

??? "Second approach"

    Use look up table.

    ```java
    public static short parity(long x) {
      int parity = 0;
      while (x != 0) {
        parity += lookup((short) x);
        x = x >> 4;
      }
      return (short) (parity % 2);
    }

    private static int lookup(short x) {
      return switch (x & 0b1111) {
        case 0b0001, 0b0010, 0b0100, 0b1000, 0b1110, 0b1101, 0b1011, 0b0111 -> 1;
        default -> 0;
      };
    }
    ```

    $O(\frac{n}{d})$ where $d$ is word size of our cache.

??? "Third approach"

    Note that parity of a number $b_{63}b_{62}b_{61}\dots b_1b_0$ is:

    $$
    \begin{align}
    & = b_{63} \oplus b_{62} \oplus b_{61} \oplus \dots \oplus b_1 \oplus b_0 \\
    & = (b_{63} \oplus b_{62} \oplus \dots b_{32}) \oplus (b_{31} \oplus b_{30} \oplus \dots b_0) \\
    & = (b_{63} \oplus b_{62} \oplus \dots b_{48}) \oplus (b_{47} \oplus b_{46} \oplus \dots b_{32}) \oplus (b_{31} \oplus b_{30} \oplus \dots b_{16}) \oplus (b_{15} \oplus b_{14} \oplus \dots b_{0}) \\
    & = \dots
    \end{align}
    $$

    We exploit the fact that the xor operator is working at number level and not bit level, thus can perform 64 operations in a single step. This allows us to calculate xor of all bits in $6$ steps ($2^6 = 64$).

    ```java
    public static short parity(long x) {
      x = (x >> 32) ^ x;
      x = (x >> 16) ^ x;
      x = (x >> 8) ^ x;
      x = (x >> 4) ^ x;
      x = (x >> 2) ^ x;
      x = (x >> 1) ^ x;
      return (short) (x & 1);
    }
    ```

    $O(\log_2{n})$, since we halve the number of bits in each step.