# Reverse bits

## Description

Given a number $n$, reverse order of its bits.

## Example

```
 input = 0b1011
output = 0b1101
```

## Stub

```java
public static long reverseBits(long x) {
  // Fill me.
}
```

## Solution

??? "First approach"

    Simply extract the last bit of $x$ and set it back in output number $y$. In each step, right shift $x$ and left shift $y$.

    ```java
    public static long reverseBits(long x) {
      long y = 0;
      for (int i = 0; i < Long.BYTES * Byte.SIZE; i++) {
        y = (y << 1) | (x & 1);
        x = x >>> 1;
      }
      return y;
    }
    ```

    !!! tip

        You can't check for $x \ne 0$ and instead needs to run the loop for size of the word. In this case that'll be 64.

??? "Second approach"

    Use lookup table. The idea is that reversing all bits is same as reversing bits within a chunk, be it a nibble, a short, an int etc; and then arranging those chunks in reverse order.

    $$
    \begin{align}
    x & = [1 \ 2 \ 3 \ 4 \ a \ b \ c \ d] \\
    & = [1 \ 2 \ 3 \ 4] [a \ b \ c \ d] \\
    & = [4 \ 3 \ 2 \ 1] [d \ c \ b \ a] \\
    & = [d \ c \ b \ a] [4 \ 3 \ 2 \ 1] \\
    & = [d \ c \ b \ a \ 4 \ 3 \ 2 \ 1] = \text{reverse}(x)
    \end{align}
    $$

    ```java
    public static long reverseBits(long x) {
      long y = 0;
      for (int i = 0; i < 16; i++) { // 64 / 4 = 16
        y = y << 4 | lookup((int) x & 0b1111);
        x = x >> 4;
      }
      return y;
    }

    private static int lookup(int x) {
      return switch (x) {
        case 0b0001 -> 0b1000;
        case 0b0010 -> 0b0100;
        case 0b0011 -> 0b1100;
        case 0b0100 -> 0b0010;
        case 0b0101 -> 0b1010;
        case 0b0110 -> 0b0110;
        case 0b0111 -> 0b1110;
        case 0b1000 -> 0b0001;
        case 0b1001 -> 0b1001;
        case 0b1010 -> 0b0101;
        case 0b1011 -> 0b1101;
        case 0b1100 -> 0b0011;
        case 0b1101 -> 0b1011;
        case 0b1110 -> 0b0111;
        case 0b1111 -> 0b1111;
        default -> x;
      };
    }
    ```