# Compute rows in Pascal's Triangle

## Description

Given $n \ge 0$ return the first $n$ rows of the Pascal's triangle.

## Example

```
1 =    1
2 =   1 1
3 =  1 2 1
4 =  1 3 3 1
5 = 1 4 6 4 1
```

Recall from [Combinatorics](/maths/combinatorics/p-and-c/) section that this basically represents:

$$
\begin{alignat}{1}
& ^0\mathrm{C}_0 \\
^1\mathrm{C}_0 & \hspace{1.6em} ^1\mathrm{C}_1 \\
^2\mathrm{C}_0 \hspace{1.6em} & ^2\mathrm{C}_1 \hspace{1.6em} ^2\mathrm{C}_2 \\
& \dots \\
\end{alignat}
$$

where 

$$
^n\mathrm{C}_r = \dfrac{{}^n\mathrm{ P }_r}{r!} = \dfrac{n!}{(n-r)!r!}
$$

## Stub

```kotlin
fun generatePascalTriangle(numRows: Int): MutableList<MutableList<Int>> {
    // TODO - you fill in here.
}
```

## Solution

??? "Expand"

    There are two key insights we use to optimally generate the rows:

    - $^n\mathrm{C}_0 = 1$
    - $^n\mathrm{C}_{r+1} = ^n\mathrm{C}_r \cdot \dfrac{n - r}{r + 1}$

    So we start with $^n\mathrm{C}_0$ and induce the remaining elements of the row.

    ```kotlin
    fun generatePascalTriangle(numRows: Int): MutableList<MutableList<Int>> {
      if (numRows == 0) return mutableListOf()
      return helper(numRows - 1)
    }

    fun helper(numRows: Int): MutableList<MutableList<Int>> {
      val triangle = mutableListOf(mutableListOf(1))
      for (n in 1..numRows) {
        triangle += generateRow(n)
      }
      return triangle
    }

    private fun generateRow(n: Int): MutableList<Int> {
      val row = mutableListOf(1) // [nC0]

      // r is the previous entry, this iteration is r+1
      for (rPlusOne in 1..n) {
        val r = rPlusOne - 1
        val prev = row.last().toLong() // (1)
        row += (prev * (n - r) / (r + 1)).toInt()
      }

      return row
    }
    ```

    1. We need to cast this to `Long` so the multiplication can go through without overflow.