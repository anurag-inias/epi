# Compute a random permutation

## Description

Given a positive integer $n$, generate a random permutation $[0, 1, \dots, n-1]$.

## Stub

```kotlin
fun computeRandomPermutation(n: Int): MutableList<Int> {
  // TODO - you fill in here.
}
```

## Solution

??? "Expand"

    A naive approach would be to randomly generate numbers in range $[0, n)$ and append them to a list, while making sure there are no duplicates. This would of course be quite wasteful as the random number generator will keep spitting duplicates over time and we'll have to waste time deduping it.

    Instead, we can simply start with a list `[0, n)` and then use Fisher-Yates shuffle to turn this into a random permutation.

    ```kotlin
    fun computeRandomPermutation(n: Int): MutableList<Int> {
      val permutation = (0..<n).toMutableList()
      
      val rand = ThreadLocalRandom.current()
      for (destination in permutation.lastIndex downTo 0) {
        // set index i with a random number from range [0, i].
        val i = rand.nextInt(0, destination+1)
        permutation.swap(i, destination)
      }

      return permutation
    }

    private fun <T> MutableList<T>.swap(i: Int, j: Int) {
      val t = this[i]
      this[i] = this[j]
      this[j] = t
    }
    ```