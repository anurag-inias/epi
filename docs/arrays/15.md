# Generate nonuniform random numbers

## Description

You are given a list of values $[v_0, v_1, \dots, v_{n-1}]$ and their respective probabilities $[p_0, p_1, \dots, p_{n-1}]$. Assuming you have access to a random number generator that returns a `double` in range $[0.0, 1.0]$, write a function to draw $v_i$ with probability $p_i$.


## Stub

```kotlin
fun nonuniformRandomNumberGeneration(
  values: MutableList<Int>,
  probabilities: MutableList<Double>
): Int {
    // TODO - you fill in here.
}
```

## Solution

??? "Expand"

    First of all, $[v_0, v_1, \dots, v_{n-1}]$ is immaterial. The exact values of $v_i$ can be anything.

    Now let's take a simple example:

    ```
          values = [a, b, c, d]
    probabilities = [0.1, 0.3, 0.2, 0.4]
    ``` 

    what this really means is that we are to draw a **uniformly** random value from the list below:

    ```
    [a, b, b, b, c, c, d, d, d, d]
    ```

    We can translate this finding into our algorithm:

    1. Update the `probabilities` array into cumulative distribution:

        $$
        [p_0, p_1, p_2, \dots, p_{n-1}] \rightarrow [p_0, p_0+p_1, p_0+p_1+p_2, \dots, 1.0]
        $$

    2. next, simply call our `randomDouble` function to draw a number `n` in range $[0.0, 1.0]$.

    3. Find index $i$ of the interval in which $n$ falls into. Going from left to right, this would be the first interval where $n > p_i$.

    4. Return $v_i$.

    ```kotlin
    fun nonuniformRandomNumberGeneration(
      values: MutableList<Int>,
      probabilities: MutableList<Double>
    ): Int {
      // PDF to CDF
      val probabilities = probabilities.toList().toMutableList()
      for (i in 1 until probabilities.size) {
        probabilities[i] += probabilities[i-1]
      }

      // Draw a random number in [0.0, 1.0]
      val draw = ThreadLocalRandom.current().nextDouble(0.0, 1.0)

      // Find the index of the inverval it falls in.
      var index = probabilities.binarySearch(draw)

      // When dealing with doubles, it's very unlikely we will find an 
      // exact match. Instead, almost always we will get an inverted index
      if (index < 0) index = -(index + 1)
      return values[index]
    }
    ```

    !!! tip
    > `binarySearch` returns:
    > the index of the element, if it is contained in the list within the specified range; otherwise, the inverted insertion point `(-insertion point - 1)`. The insertion point is defined as the index at which the element should be inserted, so that the list (or the specified subrange of list) still remains sorted. 

    So we have:

    $$
    \begin{align}
    \text{binarySearch} &= -\text{insertion_point} - 1 \\
    \text{insertion_point} &= -\text{binarySearch} - 1 \\
    &= -(\text{binarySearch} + 1)
    \end{align}
    $$

     