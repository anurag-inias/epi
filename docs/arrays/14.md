# Compute a random subset

## Description

Given positive integers $n$ and $k$, generate a random subset of size $k$ from the domain $[0, 1, \dots, n-1]$.

## Stub

```kotlin
fun randomSubset2(n: Int, k: Int): MutableList<Int> {
    // TODO - you fill in here.
}
```

## Solution

??? "Approach 1"

    A somewhat naive solution using **rejection sampling**. We keep generating a random number from range $[0, n)$ and add it to our subset. We simply have to make sure not to pick the same number twice.

    ```kotlin
    fun randomSubset2(n: Int, k: Int): MutableList<Int> {
      val rand = ThreadLocalRandom.current()
      val subset = mutableSetOf<Int>()

      while (subset.size < k) {
        subset.add(rand.nextInt(0, n))
      }

      return subset.toMutableList()
    }
    ```

    This will work fine for most cases where $k << n$. But as $k \rightarrow n$, there will be too many rejections.

??? "Approach 2"

    Recall the problem [Sample offline data](11.md) where we are tasked to come up with a random sample of size $k$ from a list of size $n$.

    ```kotlin
    fun randomSampling(k: Int, A: MutableList<Int>) {
      val rand = ThreadLocalRandom.current()
      val n = A.size

      for (i in 0 until k) {
        // swap index i with a random index in [i, n)
        val j = rand.nextInt(i, n)
        A.swap(i, j)
      }
    }
    ```

    This problem is **exactly the same**. We can populate $A = [0, 1, 2, \dots n)$ and call `randomSampling` as subroutine. However, what happens when $n$ is very large?

    This is where we use a **virtual array**. Instead of $A$ being real, we imaging an array $A$ where $A[i] = i$. We then keep track of shuffling of its element using a map:

    $$
    \text{moved}[\text{from}] = \text{to}
    $$

    and then re-write `randomSampling` with our **virtual/conceptual** array $A$:

    ```kotlin
    fun randomSubset(n: Int, k: Int): MutableList<Int> {
      val rand = ThreadLocalRandom.current()
      val moved = mutableMapOf<Int, Int>() // (1)
      val subset = mutableListOf<Int>()

      for (i in 0 until k) {
        val j = rand.nextInt(i, n)
        val valAtJ = moved[j] ?: j // (2)
        val valAtI = moved[i] ?: i // (3)
        subset.add(valAtJ)

        // book-keeping
        moved[i] = valAtJ
        moved[j] = valAtI
      }
      return subset
    }
    ```
    
    1. If key $i$ is not found in `moved` then it means value at index $i$ has not been moved. That is, $A[i] = i$. If $A[i] = v$, then `moved[i] = r`.
    2. We are recoving the true value at index $i$. If no value is found, then it's simply $i$ since $A[i] = $. 
    3. this line must be after `rand.nextInt` call.