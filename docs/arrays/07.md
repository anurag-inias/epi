# Buy and sell a stock twice

## Description

Write a program that computes the maximum profit that can be made by buying and
selling a share at most twice. **The second buy must be made on another date after the first sale.**

This is different from __Buy and sell stock multiple times__, which allows you to be greedy. Whereas this requires us to be selective.

## Example

```
 Input = [12, 11, 13, 9, 12, 8, 14, 13, 15]
Output = 10 (9-12, 8-15)
```

## Stub

```java
public static double buyAndSellStockTwice(List<Double> prices) {
  // Fill here.
}
```

## Solution

??? "Approach 1"

    Divide and Conquer. First find the buy and sell date for the most profitable trade. 
    
    Now the second most profitable trade must either:
    
    1. complete before we bought for the most profitable trade.
    2. or start after we sold for the most profitable trade.
    
    ```java
    public static double buyAndSellStockTwice(List<Double> prices) {
      int[] best = helper(prices, 0, prices.size());
      int[] left = helper(prices, 0, best[0]);
      int[] right = helper(prices, best[1]+1, prices.size());

      return profit(prices, best) + Math.max(profit(prices, left), profit(prices, right));
    }

    // "Buy and Sell stock once" as subroutine. 
    // Instead of returning the max profit, it returns the buy and sell
    // dates of the most profitable trade.
    private static int[] helper(List<Double> price, int start, int end) {
      double maxProfit = 0.0, minPrice = Double.MAX_VALUE;
      int minPriceOn = -1;
      int maxProfitBuyOn = start;
      int maxProfitSellOn = start;

      for (int i = start; i < end; i++) {
        double profit = price.get(i) - minPrice;
        if (profit > maxProfit) {
          maxProfitBuyOn = minPriceOn;
          maxProfitSellOn = i;
        }
        if (price.get(i) < minPrice) {
          minPrice = price.get(i);
          minPriceOn = i;
        }
      }

      return new int[]{maxProfitBuyOn, maxProfitSellOn};
    }

    // helper function to extract the profit from the buy-sell dates. 
    private static double profit(List<Double> price, int[] buySell) {
      return price.get(buySell[1]) - price.get(buySell[0]);
    }
    ```

??? "Approach 2"

    We can think of the second trade as not an independent trade, but a continuation of the previous trade.

    When we are buying the second stock, don't treat the cost of it as `price[i]`, but as `price[i] - profit`, where `profit` is what we earned from the first trade.

    ```java
    public static double buyAndSellStockTwice2(List<Double> prices) {
      double firstBuyCost = Double.MAX_VALUE;  // first trade: bought at +INF
      double firstBuyProfit = 0.0;             // first trade: profit none
      double secondBuyCost = Double.MAX_VALUE; // second trade: bought at +INF 
      double secondBuyProfit = 0.0;            // second trade: profit none

      for (double price : prices) {
        // This is same as "Buy and sell once"
        firstBuyProfit = Math.max(firstBuyProfit, price - firstBuyCost);
        firstBuyCost = Math.min(firstBuyCost, price);

        // new bits:
        
        // profit calculation remains same.
        secondBuyProfit = Math.max(secondBuyProfit, price - secondBuyCost);
        // cost calculation is "subsidized".
        secondBuyCost = Math.min(secondBuyCost, price - firstBuyProfit);
      }

      // since we subsidized the buying of second stock, the profit
      // here incorporates the profit from first sell.
      return secondBuyProfit;
    }
    ```