# Compute the spiral ordering of a 2D array

## Description

Given a 2D array, print its spiral traversal

## Example

![](17.svg)

## Stub

```kotlin
fun matrixInSpiralOrder(squareMatrix: MutableList<MutableList<Int>>): MutableList<Int> {
    // TODO - you fill in here.
}
```

## Solution

??? "Expand"

    Let's get a few things cleared first:

    1. Notice that the number of steps in each arm before the direction changes is $side-1$. For example, in a $4 \times 4$ matrix we traverse 3 steps to the right and then turn down, not 4.
    2. The number of steps after which direction changes is not constant. Again, in a $4 \times 4$ matrix, the outermost loop turns at 3 steps, 3 steps, 3 steps, and then at 2 steps.
    3. The circumference size is also not staightforward. For a $1 \times 1$ matrix, it's just 1. But for everything else, it's $2n - 2(n-2)$.

    All this to say, that it's not stairhgforward to setup changing of direction. So what we do is layer-by-layer traversal instead.

    ```kotlin
    val direction = mutableListOf(
      0 to 1, // row, col
      1 to 0,
      0 to -1,
      -1 to 0,
    )

    fun matrixInSpiralOrder(squareMatrix: MutableList<MutableList<Int>>): MutableList<Int> {
      val traversal = mutableListOf<Int>()
      var start = 0
      var end = squareMatrix.size - 1

      while (end - start + 1 > 0) {
        traversal.addAll(
          shellTraversal(squareMatrix, start, end - start + 1)
        )
        start++
        end--
      }

      return traversal
    }

    private fun shellTraversal(
      squareMatrix: MutableList<MutableList<Int>>,
      start: Int,
      side: Int,
    ): MutableList<Int> {
      val traversal = mutableListOf<Int>()
      val circumference = when(side) {
        1 -> 1
        else -> 2 * side + 2 * (side - 2)
      }
      var d = 0
      var steps = 0
      var (r, c) = start to start

      while (steps < circumference) {
        traversal.add(squareMatrix[r][c])
        r += direction[d].first
        c += direction[d].second
        steps++
        if (steps % max(1, side - 1) == 0) {
          d = (d + 1) % direction.size
        }
      }

      return traversal
    }
    ```