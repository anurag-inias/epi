# Multiply arbitrary-precision integers

## Description

Given two lists, represending the digits of arbitrary length integer, multiply the two.

## Example

```
 Input = [1, 2, 3], [1, 5]
Output = [1, 8, 4, 5]

 Input = [1, 2, 3], [-7]
Output = [-8, 6, 1]
```

## Stub

```java
public static List<Integer> multiply(List<Integer> num1, List<Integer> num2) {
  // Fill here.
}
```

## Solution

??? "Expand"

    Simple grade-school algorithm. With some basic sanity checks:

    1. Check the sign of first digit of both lists to figure out the sign of the product.
    2. Trim zeros from the front once the product is calculated.

    === "Actual product"

        ```java
        // e.g. [1, 2, 3] * [1, 5]
        public static List<Integer> multiply(List<Integer> num1, List<Integer> num2) {
          boolean productNegative = (num1.getFirst() * num2.getFirst() < 0); // (1)
          num1.set(0, Math.abs(num1.getFirst()));
          num2.set(0, Math.abs(num2.getFirst()));

          List<Integer> product = new LinkedList<>();

          int zeroes = 0; // (2)
          for (int i = num2.size() - 1; i >= 0; i--) {
            List<Integer> num = new LinkedList<>(num1); // [1, 2, 3] * 1

            multiply(num, num2.get(i)); // [1, 2, 3] * 1
            for (int k = 1; k <= zeroes; k++) // [1, 2, 3, 0]
              num.add(0);
            add(product, num); // [6, 1, 5] + [1, 2, 3, 0]

            zeroes++;
          }

          if (productNegative) {
            product.set(0, -product.getFirst());
          }
          // Turn [0, 0, 0, 0] into [0].
          while (product.size() > 1 && product.getFirst() == 0) {
            product.removeFirst();
          }
          return product;
        }
        ```

        1. Product is negative if either of the numbers are negative, but not both.
        2. Track how many zeroes to pad at the end.


    === "Subroutine for `[1, 2, 3] * 5`"

        ```java
        private static void multiply(List<Integer> num, int p) {
          int carry = 0;
          int i = num.size() - 1;

          while (i >= 0 || carry > 0) {
            int prod = (i < 0 ? 0 : num.get(i)) * p + carry;
            if (i < 0) {
              num.addFirst(prod % 10);
            } else {
              num.set(i, prod % 10);
            }
            carry = prod / 10;
            i--;
          }
        }
        ```

    === "Subroutine for `[6, 1, 5] + [1, 2, 3, 0]`"

        ```java
        private static void add(List<Integer> num1, List<Integer> num2) {
          int carry = 0;
          int i = num1.size() - 1;
          int j = num2.size() - 1;

          while (i >= 0 || j >= 0 || carry > 0) {
            int sum = (i < 0 ? 0 : num1.get(i)) + (j < 0 ? 0 : num2.get(j)) + carry;
            if (i < 0) {
              num1.addFirst(sum % 10);
            } else {
              num1.set(i, sum % 10);
            }
            carry = sum / 10;
            i--;
            j--;
          }
        }
        ```



