# Compute the next permutation

## Description

Given an array of integer $A$ (which can have duplicates), find the next permutation in lexicographical order. 

Once we reach to the last permutation, return an empty list.

## Examples

-  $[1, 2, 3, 4] \rightarrow [1, 2, 4, 3]$
-  $[1, 2, 4, 3] \rightarrow [1, 3, 2, 4]$
-  $[1, 3, 2, 4] \rightarrow [1, 3, 4, 2]$
-  $[1, 3, 4, 2] \rightarrow [2, 1, 3, 4]$
-  $[4, 3, 2, 1] \rightarrow []$

## Stub

```kotlin
fun nextPermutation(perm: MutableList<Int>): MutableList<Int> {
  // TODO - you fill in here.
}
```

## Solution

??? "Expand"

    There is no clever algorithm. We just need to think of two example scenarios.

    - `[1, 2, 3] -> [1, 3, 2]` 
    - `[0, 3, 2, 1] -> [1, 0, 2, 3]`

    while the two look different, we are doing the same thing:

    - find the peak index $k$ at the end of the permutation. That is: $p_{k-1} < p_k > p_{k+1}$.
    - $p_k$ is the starting index of a decreasing subsequence.
    - Find the index $l$ of the smallest value in this subsequence that's still $> p_{k-1}$.
    - Swap $l$ and $p_{k-1}$.
    - Sort range $[k, n)$.

    This is basically how we increament a counter.

    ```kotlin
    fun nextPermutation(perm: MutableList<Int>): MutableList<Int> {
      // Find the peak of the mountain, starting from the end.
      var k = perm.lastIndex
      while (k > 0 && perm[k-1] >= perm[k]) {
        k--
      }
      // Peak is at the front of the array, so this is the last permutation.
      if (k == 0) return mutableListOf()

      // k is the peak of the mountain.
      // index of the smallest element > perm[k-1] is l
      val l = smallestNumberLargerThan(perm, perm[k-1], k, perm.size)

      // swap l and k-1
      val t = perm[l]
      perm[l] = perm[k-1]
      perm[k-1] = t

      // sort [k, n)
      val sorted = perm.slice(0 until k) + perm.slice(k until perm.size).sorted()
      return sorted.toMutableList()
    }

    // Binary search. Except here we are expecting `perm` to be
    // sorted in descending order, so all operations are reversed.
    private fun smallestNumberLargerThan(perm: List<Int>, needle: Int, start: Int, end: Int): Int {
      var l = start
      var r = end - 1
      while (l <= r) {
        val m = l + (r - l) / 2
        when(needle.compareTo(perm[m])) {
          // needle < middle
          // since perm is descending, search further in right half.
          -1 -> l = m+1
          // needle > middle
          // since perm is descending, search further in left half.
          1 -> r = m-1
          // needle == middle
          // However, we are not actually looking for needle
          // but the smallest value > needle. So it must be to the left
          // of here.
          0 -> r = m-1
        }
      }
      // l and r would've swapped places: ...r, l...
      return r
    }
    ```